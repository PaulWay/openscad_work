Primitive and building block libraries
--------------------------------------

These are the basic functions I use for most of my other modelling.

**File: `pwlib_boards.scad`**

Functions to generate cases for PCBs.

**File: `pw_funcs.scad`**

Functions:

- `dovetail_outer(x, y, spread, thick, clear=0.0, leftward=true)`
  - Generates a list of points for a linear_extruded polygon that forms the
    'outside' of a dovetail joint.
  - `x`, `y` - total size of the joint
  - `thick` - the thickness of the walls at the back of the dovetail
  - `spread` - the distance 'in' from each side the 'mouth' of the dovetail
    goes.  If `spread` is zero, there is no angle to the dovetail and it
    becomes a finger joint.
  - `clear` is the clearance (see below).
- `dovetail_inner(x, y, spread, thick, clear=0.0, leftward=true)`
  - Generates a list of points for a linear_extruded polygon that forms the
    'inside' of a dovetail joint of the given dimensions.  `clear` is the
    amount of clearance on each part - when `clear` is zero, they fit
    exactly; if set to 1 there would be 1mm of clearance between dovetail and
    outer.
- `arith_spiral(start_rad, end_rad, steps, angle=360)`
  - Generates a list of points that forms an arithmetic spiral - i.e. a fixed
    distance between arcs of the spiral.  This is only one side - you need to
    wrap this in with other points to form a 'solid' polygon that can be
    extruded.  Points start on the X axis and the arc goes anti-clockwise from
    there - you can make the angle negative to go in the other direction.  The
    start can be larger or smaller than the end.
  - `start_rad` - the radius distance from the centre at the start of the spiral
  - `end_rad` - the radius distance from the centre at the end of the spiral
  - `steps` - number of steps - a bit like the $fn parameter.
  - `angle` - total arc covered.  This can be greater than 360 if you want
    multiple revolutions of the spiral.

**File: `pw_primitives.scad`**

The basic modules I use to base a lot of my other modelling on.

Modules:

- **Arrangers**
  - `txl(x=0, y=0, z=0)`
    - an abbreviated translate, usually if you just want to move in one axis
  - `rot(x=0, y=0, z=0)`
    - an abbreviated rotate, usually if you just want to rotate about one axis
  - `hex_distribute(num_x, num_y, diameter)`
    - arrange children in a hexagonal lattice.  Every alternate Y row is
      offset by half the diameter, and the rows are offset such that the
      centres are always `diameter` apart (i.e. the distance in the Y axis
      between rows is `diameter*sin(60)`).
    - `num_x` - the number of children in the X direction
    - `num_y` - the number of children in the Y direction
    - `diameter` - the distance between each centre.
  - `rotate_distribute(number, angle=360, last_fencepost=false)`
    - arrange children by rotating them by successive increments.  Only the
      rotation is done; children must be translated off the origin in order to
      be in different positions.
  - `linear_distribute(start, step, end, tvec = [1, 0, 0])`
    - Distribute children in a for loop, but multiplying the translation
      vector `tvec` by the loop value.
- **Modifiers**
  - `flatten(height)`
    - Take any child object and trim off the bits below the XY plane, and
      above a plane `height` above the XY plane.  Useful for flattening
      round objects onto a plane.
` **Twist generators**
  - `arith_twist(start_angle, stop_angle, height, steps)`
    - Produces a series of `linear_extrude`d segments of a child 2D object,
      extruded with gradually increasing twist angles.  The final object will
      be `height` high.  The final total twist (should you need to align
      something with the final position of your object) is echoed.
- **Simple cubic modules**
  - `rounded_box(length, width, height, outer_r, remove_top_face=true, method="mink")`
    - A box with rounded corners (chamfered), with the top face rounded or flat.
      This can be generated by a `minkowski` operator, which is simpler but
      may be more computationally complicated, or a `hull` of cylinders and
      spheres which is more objects but may be more computationally simple to
      render.  So far tests don't show one being much faster than the other.
      Rumours of a third, `union` method, are so far unconfirmed.
  - `chamfered_cube(x, y, z, side, chamfer_x=true, chamfer_y=true, chamfer_z=true)`
  - `filleted_cube(x, y, z, fillet_rad)`
  - `hexahedron(corners, convexity=1)`
  - `filleted_hexahedron(x1, y1, x2, y2, height, fillet_rad)`
    - A six-sided object, with bottom and top parallel to the XY plane
      (bottom thereon, top `height` away).  Its 'vertical' edges are at
      positive and negative (x1,y1) at the base and (x2,y2) at top, and these
      edges are formed by cylinders of radius `fillet_rad`.
  - `r_diamond_2d(x, y, r)`
    - A diamond of maximum dimension `x`, `y` with rounded corners of radius `r`.
  - `r_diamond_screw_plate(x, y, r, hole_x, hole_r, thick)`
    - A rounded diamond-shaped plate with two holes that you can use as a
      base for other objects.  The plate diamond is of maximum dimensions
      `x`, `y`, the corners are of radius `r`. The two screw holes are `hole_x`
      from the centre away in positive and negative X, and are of radius
      `hole_r`.  The whole plate is `thick` height in Z.
- **Rings and Cones**
  - function `radius_from_d_or_r(d=undef, r=undef)`
    - Used in the below functions that take either a `d` or `r` parameter
      similar to the `circle` and `cylinder` primitives.  This produces a
      calculated radius that other modules can use, and makes sure that one
      and only one of the `d` and `r` parameters is given.
  - `cylinder_outer(h, d=undef, r=undef)`
  - `cylinder_mid(h, d=undef, r=undef)`
  - `circle_outer(d=undef, r=undef)`
  - `circle_mid(d=undef, r=undef)`
  - `cylinder_from_to(from, to, d=undef, r=undef)`
    - Move and rotate a cylinder so its start is the `from` vector and its end
      is the `to` vector.  Specify at least one of `r` or `d`, similar to a
      cylinder.
  - `chamfered_cylinder(height, d=undef, r=undef, chamfer=0)`
  - `rounded_cylinder(h, d=undef, r=undef, corner_r, mink=false)`
    - A cylinder with rounded edges.  If `mink` is left as false this is
      generated using a `rotate_extrude`, otherwise a `minkowski` operation
      is used.
  - `rounded_cylinder_hole(h, d=undef, r=undef, corner_r, top_r=undef)`
    - A cylinder 'hole' to cut out of another object, so that its bottom is
      rounded inward and a rounded lip is taken out of the surrounding material.
  - `ellipse(x, y)`
  - `ellipsoid(x, y, height)`
  - `elliptical_pipe(x, y, height, thick)`
  - `pipe_rt(height, radius, thickness)`
  - `pipe_oi(height, o_radius, i_radius)`
  - `hollow_cone_rt(height, bottom_radius, top_radius, thickness)`
  - `hollow_cone_oi(height, o_bot_radius, i_bot_radius, o_top_radius, i_top_radius)`
  - `sphericone(sphere_r, cone_base_r, angle=40, truncate_at_xy_plane=false)`
    - A sphere of `sphere_r` radius, standing on a cone whose base is of
      `cone_base_r` radius, where the angle of the cone is `angle` from the
      horizontal.  The cone height is calculated such that it meets the
      sphere at a tangent.
    - This is for printing a sphere, sitting on some other
      object such as a cylinder or flat surface, without needing support.
      This will emit the total height, which is calculated; if you need an
      absolute maximum height you will need to put something like a cylinder
      underneath it based on that total sphericone height.
- **Cylinder segments**
  - `half_cylinder(height, radius)`
  - `cylinder_segment(height, radius, angle=360)`
  - `pipe_rt_segment(radius, thickness, height, angle)`
- **Cylinders going places**
  - `cylinder_from_to(from, to, d, r)`
    - A cylinder from a source 3D place to a destination 3D place.  This is
      achieved by moving and then rotating a cylinder into position.
  - `rounded_cylinder_from_to(from, to, d, r)`
    - The same thing but with spheres on the ends.  Really easy because this
      is just a `hull()` operation on two spheres; this may be at the expense
      of CGAL computation.  Note that the `from` and `to` coordinates are the
      _centres_ of the spheres, not the tips.
  - `cylinder_xyzs(x1, y1, x2, y2, height, r)`
    - A cylinder, going from `[x1, y1, 0]` to `[x2, y2, height]`.  The
      cylinder is sheared and translated, so its top and bottom are still
      parallel to the XY plane.  Again, the X and Y coordinates are the
      _centres_ of the cylinders, not the outside edges.
- **Toroids and pipe bends**
  - `torus(outer, inner, x_stretch=1, angle=360)`
    - The standard torus, with the ability to scale it in the X dimension,
      and get a toroidal arc (because, of course, this is produced with a
      `rotate_extrude`).
  - `toroidal_pipe(bend_radius, pipe_i_radius, thickness, angle=360)`
    - A hollow toroid, given the inner radius and the wall thickness.
  - `quarter_torus_bend_snub_end(outer_rad, width, angle, outer=true)`
    - A quarter circle in a toroidal arc, either on the outer or inner bottom
      quarter of the circle.
    - This can be used to subtract from a surface to fillet the join between
      a base and a circular fitting.
  - `conduit_angle_bend(bend_radius, pipe_radius, bend_angle, thickness,
    join_length, join_radius=undef,
    join_a=true, join_b=true, flare_a=true, flare_b=true,
    curved_a=false, curved_b=false)`
    - The handy dandy all-purpose generator for curved parts to join two
      pipes together.  `pipe_radius` is the internal pipe diameter, and the
      thickness is then added to that.
    - Each end, 'a' (the one on the XZ plane) and 'b' (the other one), can be
      manipulated in several ways:
      - If `join_(a|b)` is `false`, then no join segment is added on that end.
      - If `flare_(a|b)` is `false`, then that end is the same diameter as the
        overall pipe; otherwise it's wider, so that a similar pipe of the same
        diameter would fit into it.
      - If `curved_(a|b)` is `false` then that join end is straight (to fit a
        straight pipe); if `true` that join end is curved (to fit into
        another curved pipe).  `curved_(a|b)=true` allows multiple curved
        segments to be joined together into a bend of a radius greater than
        would fit in a printer or would be printed without supports.
    - See `Test_pieces/conduit_angle_bend*.scad` for examples and tests.
- **Rectangular tubes and toroids**
  - `rectangular_pipe(width, height, thickness, length)`
  - `rectangular_tube(x, y, thickness, height)`
  - `rectangular_cone(x1, y1, x2, y2, height)`
  - `rectangular_torus(outer, inner, height, angle=360)`
  - `rectangular_pipe_bend_basic(width, height, thickness, inner_radius, bend_angle)`
  - `rectangular_pipe_bend(
    width, height, thickness, inner_radius, bend_angle, join_length,
    overlap_len, join_a=true, join_b=true, flare_a=true, flare_b=true,
    curved_a=false, curved_b=false
    )`
    - A curved rectangular pipe, rotating around the Z axis so X=width and
      Z=height.  This can produce straight or curved join segments at either
      end ('a' is the end at the XZ plane, 'b' is the other), either flared
      (i.e. accepting a pipe of this width and height) or not.
- **Springs**
  - `coil_spring(spring_r, wire_r, rise_per_rev, turns, step_deg)`
  - `flat_spring(length, width, height, gap_length, segments)`
  - `rect_circ_spring(in_radius, out_radius, angle, segments, height, thickness)`
- **Bolt shapes**
  - These are used for 'cutting out' a hole for a bolt in something else.
  - `countersunk_bolt_hole(shaft_d, shaft_len, head_d, head_len)`
  - `flat_head_bolt_hole(shaft_d, shaft_len, head_d, head_len)`
  - `hex_head_bolt_hole(shaft_d, shaft_len, head_d, head_len)`
    - A bolt with a hexagonal head - useful for holding the nut or the bolt
      still while you screw the other in.
- **Triangles**
  - `equ_triangle(side)`
    - An equilateral triangle, with one point on the origin and one side along
      the X axis.
  - `arb_triangle(ab, bc, ac)`
    - An arbitrary triangle, given three side lengths.  Point A is at the
      origin, and point B is along the X axis (i.e. at `(ab, 0)`).  Point C
      has its X and Y coordinates calculated.
- **Hexagons**
  - `hexagon(radius)`
    - A 2D hexagon
  - `hexagon_solid(radius=0, height=0, side2side=0)`
    - A `linear_extrude`d hexagon.  Can be specified by either radius (the
      length of one side, or the distance from the center to one corner), or
      the 'side to side' measurement of the distance between two parallel
      side.
  - `tapered_hexagon(radius1, radius2, height)`
    - A hexagon that goes from radius1 to radius2 as it goes up.

**File: `gears.scad`**

A borrowed gears library.  Source: https://github.com/chrisspen/gears

